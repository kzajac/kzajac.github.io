<HTML>

<HEAD>
<META http-equiv="content-type" content="text/html; charset=utf-8">
<TITLE>Julia</TITLE>
<link rel="stylesheet" type="text/css" href="../style.css">
</HEAD>

<BODY>
<TABLE WIDTH="80%" HEIGHT="90%" BORDER="0" ALIGN=CENTER>
<TR>
<TD ALIGN=CENTER>
<DIV ALIGN=left>

<hr>
  <h2> Tutorial z wykładu</h2>
	<ul>
 	<li> Uwaga: Notebooki Jupitera  renderują się na stronie githuba do html, żeby ściągnąć wersję uruchamialną 
      dla Jupitera należy wybrać opcję "Raw"
		<li> <a href=https://github.com/kzajac/kzajac.github.io/blob/master/julia/lab2/Tutorial_2.ipynb>Tutorial</a>
</ul>
  <h2> Laboratorium 2 - zadania </h2>
  <ul>
      <li> Napisać funkcję, która bierze typ i wypisuje jego graf dziedziczenia 
        np. w formie  "Any-->Number-->Real-->AbstractFloat-->Float16" (3pkt)
        <br>
        Wskazówka: wewnetrznie typy są reprezentowane jako DataType np.: 
        <br>
        <code>
          julia> typeof(Real)
          <br>
          DataType
        </code>
       <li> Stworzyć typ będący grupą algebraiczną zamkniętą ze względu na mnożenie mod N. 
	       Szczegóły:
	       <ul>
			<li> Typ powinien być   parametryzowany liczbą N wg zasady:
	       		Liczba  x należy do grupy (czyli x jest typu Gn{N}) dla konkretnego N, jeśli jest mniejsza od N 
		       i nie ma wspólnych podzielników z N większych od 1.
			 <li> Stworzyć odpowiedni konstruktor sprawdzający warunki utworzenia obiektu danej grupy:
				 Jeśli liczba jest za duża należy
		 	wyliczyć jej resztę z dzielenia przez N i jeśli nie ma ona podzielników wspólnych z N większych od 1, to można
		 	z niej utworzyć obiekt typu Gn{N}. Jesli liczba ma wspólne podzielniki należy rzucic wyjątek.
		       <li> taka grupa jest zamknięta ze względu na mnożenie modulo N czyli: jeśli <i>a</i> należy do Gn{N}
			       i <i>b</i> należy do Gn{N} to <i>c=(a*b)mod N </i> też należy do Gn{N}. Napisać metody funkcji
					'*' dla obu argumentów typu Gn{N} jak również mieszanych Gn{N} i Int64 
			<li> napisać odpowiednia funkcje konwertujaca i regułe promocji.
		       <li> napisac funkcję <i>a^x mod N</i> dla <i> a</i> będącego typu G{N} i <i>x</i> typu Int64 korzystając
			       z poprzedniej funkcji. Upewnić się, 
			       że w trakcie nie są tworzone duże liczby (duże potęgi liczby a), należy pamiętać, że 
			       wystarczy mnożyć reszty, nie trzeba "całych" liczb.
			     <li> napisać funkcję obliczającą okres danej liczby typu G{N} czyli najmniejszą liczbę naturalną r,
				     taką, że <i> a^r mod N =1</i>. Można to zrobić sprawdzająć po kolei wszystkie możliwości, można
				     też skorzystać z twierdzenia, że r musi dzielić ilość elementów w grupie 
		             <li> napisac funkcję obliczającą element b odwrotny do a, czyli taki, że (a*b) mod N =1. Mozna
				     to zrobić sprawdzając wszystkie możliwości albo stosując <a href="https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm"
												 rozszerzony algorytm Euklidesa</a>.
	</ul> 
         
  </ul>

 
<P>
<HR>
<I>Bartosz Baliś, balis at agh edu pl</I>
<BR>
<I>Maciej Malawski, malawski at agh edu pl</I>
<BR>
<I>Katarzyna Rycerz, kzajac at agh edu pl</I>
<BR>

<P> <P>

</DIV>
</TR>
</TD>
</TABLE>

</BODY>

</HTML>
